# üöÄ Advanced Algorithms Collection in C++

A comprehensive collection of algorithms implemented in C++, focusing on competitive programming, number theory, and graph algorithms. This repository serves as both a learning resource and a quick reference for various algorithmic problems.

## üìö Table of Contents

1. [Number Theory](#number-theory)
2. [Graph Algorithms](#graph-algorithms)
3. [Data Structures](#data-structures)
4. [Competitive Programming Topics](#competitive-programming)
5. [Getting Started](#getting-started)
6. [Contributing](#contributing)

## üî¢ Number Theory <a name="number-theory"></a>

- **Basic Operations**

    - GCD and LCM
    - Prime factorization
    - Sieve of Eratosthenes
    - Extended Euclidean algorithm

- **Advanced Concepts**
    - Modular arithmetic
    - Chinese Remainder Theorem
    - Wilson's theorem
    - Lucas theorem
    - Miller-Rabin primality test

## üï∏Ô∏è Graph Algorithms <a name="graph-algorithms"></a>

- **Traversal**

    - Depth-First Search (DFS)
    - Breadth-First Search (BFS)
    - Topological Sort

- **Shortest Paths**

    - Dijkstra's Algorithm
    - Bellman-Ford Algorithm
    - Floyd-Warshall Algorithm

- **Minimum Spanning Trees**

    - Kruskal's Algorithm
    - Prim's Algorithm

- **Advanced Graph Concepts**
    - Strongly Connected Components
    - Articulation Points and Bridges
    - Maximum Flow (Ford-Fulkerson)
    - Bipartite Matching

## üìä Data Structures <a name="data-structures"></a>

- **Trees**

    - Binary Search Tree
    - AVL Tree
    - Segment Tree
    - Fenwick Tree (Binary Indexed Tree)

- **Advanced Structures**
    - Disjoint Set Union (DSU)
    - Trie
    - Sparse Table
    - Heavy-Light Decomposition

## üèÜ Competitive Programming Topics <a name="competitive-programming"></a>

- **Dynamic Programming**

    - Knapsack Problems
    - Longest Common Subsequence
    - Matrix Chain Multiplication
    - Optimal Game Strategies

- **String Algorithms**

    - KMP Algorithm
    - Z Algorithm
    - Suffix Array and LCP
    - Aho-Corasick Algorithm

- **Geometry**
    - Convex Hull
    - Line Intersection
    - Point Location
    - Geometric Transformations

## üö¶ Getting Started <a name="getting-started"></a>

### Prerequisites

- C++ compiler (GCC/G++ recommended)
- C++17 or later
- Basic knowledge of algorithms and data structures

### Installation

```bash
git clone https://github.com/yourusername/cpp-algorithms.git
cd cpp-algorithms
```

### Building and Running

Each algorithm is contained in its own file and can be compiled independently:

```bash
g++ -std=c++17 source_file.cpp -o output
./output
```

## ü§ù Contributing <a name="contributing"></a>

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.

### Gradient Descent c·ªßa h√†m m·ªôt bi·∫øn

Ch·ªçn m·ªôt ƒëi·ªÉm b·∫•t k√¨ ƒë·ªÉ b·∫Øt ƒë·∫ßu v√† ƒëi v·ªÅ h∆∞·ªõng ng∆∞·ª£c ƒë·∫°o h√†m:

# $$x_{t + 1} = x_t - \eta f'(x_t)$$

Trong ƒë√≥ $\eta$ g·ªçi l√† "learning rate". Thu·∫≠t to√°n s·∫Ω l·∫∑p ƒë·∫øn khi gi√° tr·ªã t·∫°i ƒë·∫°o h√†m l√† r·∫•t nh·ªè th√¨ ta d·ª´ng thu·∫≠t to√°n, ƒë√≥ l√† √Ω t∆∞·ªüng Gradient Descent.

X√©t v√≠ d·ª• v·ªõi h√†m s·ªë:

# $$y = f(x) = x^2 + 5 \sin(x)$$

Ta c√≥ ƒë·∫°o h√†m c·ªßa h√†m s·ªë y l√†:

# $$y' = f'(x) = 2x + 5 \cos(x)$$

S·ª≠ d·ª•ng gradient descent ta c√≥ ph∆∞∆°ng tr√¨nh:

# $$x_{t + 1} = x_t - \eta(2x_t + 5\cos(x_t))$$

Ta s·∫Ω c·∫ßn m·ªôt s·ªë h√†m nh∆∞ sau:

1. grad(): calculate gradient of y'
2. cost(): calculate cost, check stop condition
3. gd(): main function, run gradient descent

### Perceptron Algorithms (PLA)

![Dog](/dog.jpg "Dog")

D√πng trong c√°c b√†i to√°n ph√¢n l·ªõp nh·ªã ph√¢n (Binary Classification)

Cho $X = [x_1, x_2,...,x_N] \in R^{d x N}$ v√† $y = [y_1, y_2, ..., y_N] \in R^{1 x N}$

Gi·∫£ s·ª≠ ta t√¨m ƒë∆∞·ª£c ranh gi·ªõi l√† m·ªôt si√™u ph·∫≥ng:

$$
    f_w(x) = w_1 x_1 + w_2 x_2 + ... + w_d x_d + w_0 = w^T x + w_0 = 0
$$

H√†m m·∫•t m√°t:

$$
    J_1(w) = \sum_{x_i \in M} (-y_i \text{sgn}(w_Tx_i))
$$

V√¨ ƒë√¢y l√† h√†m r·ªùi r·∫°c n√™n kh√≥ t√≠nh to√°n ta x√©t h√†m m·∫•t m√°t:

$$
    J(w) = \sum_{x_i \in M} (-y_i w^T x_i)
$$

$$
    \mathbf{A} =\begin{bmatrix}a_{11} & a_{12} & \cdots & a_{1n} \\a_{21} & a_{22} & \cdots & a_{2n} \\\vdots & \vdots & \ddots & \vdots \\a_{m1} & a_{m2} & \cdots & a_{mn}\end{bmatrix}\Rightarrow\det(\mathbf{A}) = \sum_{j=1}^{n} (-1)^{i+j} a_{ij} \det(\mathbf{A}_{ij})
$$
